package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"strings"
)

// ContentTypeEntry is used by the ContentTypes struct
type ContentTypeEntry struct {
	Extension   string `xml:"Extension,attr"`
	ContentType string `xml:"ContentType,attr"`
}

// ContentTypes is represents a [Content_Types].xml file from a .nupkg file
type ContentTypes struct {
	XMLName xml.Name            `xml:"Types"`
	Xmlns   string              `xml:"xmlns,attr"`
	Entry   []*ContentTypeEntry `xml:"Default"`
}

// NewContentTypes is a constructor for the ContentTypes struct
func NewContentTypes() *ContentTypes {
	ct := &ContentTypes{}
	ct.Xmlns = "http://schemas.openxmlformats.org/package/2006/content-types"
	return ct
}

// Add pushes a new extension into a ContentType struct
func (ct *ContentTypes) Add(ext string) {
	if strings.HasPrefix(ext, ".") {
		ext = strings.TrimLeft(ext, ".")
	}
	// Create a new entry
	cte := &ContentTypeEntry{Extension: ext}
	// If it already exists we can exit
	for _, e := range ct.Entry {
		if e.Extension == cte.Extension {
			return
		}
	}
	// Set the content type
	switch cte.Extension {
	case "rels":
		cte.ContentType = "application/vnd.openxmlformats-package.relationships+xml"
	case "psmdcp":
		cte.ContentType = "application/vnd.openxmlformats-package.core-properties+xml"
	default:
		cte.ContentType = "application/octet"
	}
	// Add it to the array
	ct.Entry = append(ct.Entry, cte)
}

// ToBytes produces the nuspec in XML format
func (ct *ContentTypes) ToBytes() ([]byte, error) {
	var b bytes.Buffer
	// Unmarshal into XML
	output, err := xml.MarshalIndent(ct, "", "  ")
	if err != nil {
		return nil, err
	}
	// Self-Close any empty XML elements (to match original Nuget output)
	// This assumes Indented Marshalling above, non Indented will break XML
	for bytes.Contains(output, []byte(`></`)) {
		i := bytes.Index(output, []byte(`></`))
		j := bytes.Index(output[i+1:], []byte(`>`))
		output = append(output[:i], append([]byte(` /`), output[i+j+1:]...)...)
	}
	// Write the XML Header
	b.WriteString(xml.Header)
	b.Write(output)
	return b.Bytes(), nil
}

// Rel represents a relationship used in RelFile
type Rel struct {
	Type   string `xml:"Type,attr"`
	Target string `xml:"Target,attr"`
	ID     string `xml:"Id,attr"`
}

// RelFile represents a Relationship File stored in .rels
type RelFile struct {
	XMLName xml.Name `xml:"Relationships"`
	XMLns   string   `xml:"xmlns,attr"`
	Rels    []*Rel   `xml:"Relationship"`
}

// Add appends a new relationship to the list
func (rf *RelFile) Add(t string, targ string) {
	r := &Rel{
		Type:   t,
		Target: targ,
	}
	rf.Rels = append(rf.Rels, r)
	// Add UID (Unique in this file...)
	rf.Rels[len(rf.Rels)-1].ID = fmt.Sprintf("R%015d", len(rf.Rels))
}

// NewRelFile returns a populated skeleton for a Nuget Packages Entry
func NewRelFile() *RelFile {
	// Create new entry
	rf := &RelFile{
		XMLns: "http://schemas.openxmlformats.org/package/2006/relationships",
	}
	return rf
}

// ToBytes exports structure as byte array
func (rf *RelFile) ToBytes() ([]byte, error) {
	var b bytes.Buffer
	// Unmarshal into XML
	output, err := xml.MarshalIndent(rf, "", "  ")
	if err != nil {
		return nil, err
	}
	// Self-Close any empty XML elements (NuGet client is broken and requires this on some)
	// This assumes Indented Marshalling above, non Indented will break XML
	// Break XML Encoding to match Nuget server output
	for bytes.Contains(output, []byte(`></`)) {
		i := bytes.Index(output, []byte(`></`))
		j := bytes.Index(output[i+1:], []byte(`>`))
		output = append(output[:i], append([]byte(` /`), output[i+j+1:]...)...)
	}

	// Write the XML Header
	b.WriteString(xml.Header)
	b.Write(output)
	return b.Bytes(), nil

}

// PsmdcpFile is a variation XML generated by nuget
type PsmdcpFile struct {
	XMLName        xml.Name `xml:"coreProperties"`
	XMLNSdc        string   `xml:"xmlns:dc,attr"`
	XMLNSdcterms   string   `xml:"xmlns:dcterms,attr"`
	XMLNSxsi       string   `xml:"xmlns:xsi,attr"`
	XMLNS          string   `xml:"xmlns,attr"`
	Creator        string   `xml:"dc:creator"`
	Description    string   `xml:"dc:description"`
	Identifier     string   `xml:"dc:identifier"`
	Version        string   `xml:"version"`
	Keywords       string   `xml:"keywords"`
	LastModifiedBy string   `xml:"lastModifiedBy"`
}

// NewPsmdcpFile returns a populated skeleton for a Nuget Packages Entry
func NewPsmdcpFile() *PsmdcpFile {
	// Create new entry
	pf := &PsmdcpFile{
		XMLNSdc:      "http://purl.org/dc/elements/1.1/",
		XMLNSdcterms: "http://purl.org/dc/terms/",
		XMLNSxsi:     "http://www.w3.org/2001/XMLSchema-instance",
		XMLNS:        "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
	}
	return pf
}

// ToBytes exports structure as byte array
func (pf *PsmdcpFile) ToBytes() ([]byte, error) {
	var b bytes.Buffer
	// Unmarshal into XML
	output, err := xml.MarshalIndent(pf, "", "  ")
	if err != nil {
		return nil, err
	}
	// Self-Close any empty XML elements (NuGet client is broken and requires this on some)
	// This assumes Indented Marshalling above, non Indented will break XML
	// Break XML Encoding to match Nuget server output
	for bytes.Contains(output, []byte(`></`)) {
		i := bytes.Index(output, []byte(`></`))
		j := bytes.Index(output[i+1:], []byte(`>`))
		output = append(output[:i], append([]byte(` /`), output[i+j+1:]...)...)
	}

	// Write the XML Header
	b.WriteString(xml.Header)
	b.Write(output)
	return b.Bytes(), nil
}
